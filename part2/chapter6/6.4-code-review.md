# 6.4 代码审查:让AI找出问题

## 为什么需要代码审查?

### 问题场景

```
你的代码:
✓ 能运行
✓ 得到了正确结果
✓ 没有报错

但可能存在:
❌ 性能问题(慢)
❌ 潜在bug(边界情况未处理)
❌ 安全隐患(数据泄露风险)
❌ 可读性差(别人看不懂)
❌ 不符合最佳实践
```

### 医学类比

```
代码审查 = 会诊制度

自己看病历: 可能漏诊,主观偏见
同行会诊: 发现潜在问题,提供更好方案

AI审查的优势:
- 不知疲倦,任何时候都能审查
- 无主观偏见,客观评估
- 经验丰富,见过海量代码
- 速度快,秒级反馈
```

## 代码审查的维度

### 1. 正确性(Correctness)

**检查点**:
- 逻辑是否正确
- 边界情况是否处理
- 异常情况是否考虑

### 2. 性能(Performance)

**检查点**:
- 是否有不必要的循环
- 能否使用向量化操作
- 数据结构选择是否合理

### 3. 可读性(Readability)

**检查点**:
- 变量命名是否清晰
- 代码结构是否合理
- 注释是否充分

### 4. 安全性(Security)

**检查点**:
- 是否有SQL注入风险
- 敏感数据是否保护
- 输入是否验证

### 5. 最佳实践(Best Practices)

**检查点**:
- 是否符合PEP 8规范
- 是否使用了更Pythonic的写法
- 错误处理是否完善

## AI代码审查的Prompt策略

### 策略1: 全面审查

**Prompt模板**:
```
请审查以下代码,从多个维度找出问题:

```python
[代码]
```

请检查:
1. 正确性:逻辑错误、边界情况
2. 性能:效率问题、优化空间
3. 可读性:命名、注释、结构
4. 安全性:潜在风险
5. 最佳实践:Python规范

对每个问题:
- 指出具体位置
- 说明为什么有问题
- 给出改进建议
- 提供修改后的代码
```

**实例**:

**你的代码**:
```python
def get_elderly_patients(patient_list):
    results = []
    for i in range(len(patient_list)):
        if patient_list[i]['age'] >= 60:
            results.append(patient_list[i])
    return results
```

**你问**:
```
请审查以下代码:

```python
def get_elderly_patients(patient_list):
    results = []
    for i in range(len(patient_list)):
        if patient_list[i]['age'] >= 60:
            results.append(patient_list[i])
    return results
```

从正确性、性能、可读性角度找出问题并改进。
```

**AI答**:
```
代码审查报告:

【问题1: 性能 - 不必要的索引访问】
位置: for i in range(len(patient_list))
问题: 使用索引访问效率较低,不够Pythonic
改进: 直接遍历列表

【问题2: 可读性 - 缺少文档字符串】
位置: 函数定义
问题: 没有说明函数用途、参数、返回值
改进: 添加docstring

【问题3: 正确性 - 缺少异常处理】
位置: patient_list[i]['age']
问题: 如果字典没有'age'键会KeyError
改进: 使用.get()或添加异常处理

【问题4: 性能 - 可以使用列表推导式】
位置: 整个函数
问题: 循环+append效率不如推导式
改进: 用列表推导式一行搞定

【问题5: 正确性 - 缺少输入验证】
位置: 函数开头
问题: 如果传入None或非列表会报错
改进: 添加参数验证

【改进后的代码】:

def get_elderly_patients(patient_list):
    """
    筛选60岁及以上的老年患者

    Args:
        patient_list (list): 患者列表,每个元素是字典,包含'age'键

    Returns:
        list: 老年患者列表

    Raises:
        TypeError: 如果patient_list不是列表
        ValueError: 如果patient_list为None

    Examples:
        >>> patients = [
        ...     {'name': '张三', 'age': 45},
        ...     {'name': '李四', 'age': 65}
        ... ]
        >>> elderly = get_elderly_patients(patients)
        >>> len(elderly)
        1
    """
    # 输入验证
    if patient_list is None:
        raise ValueError("patient_list不能为None")
    if not isinstance(patient_list, list):
        raise TypeError("patient_list必须是列表")

    # 使用列表推导式,性能更好
    return [
        patient for patient in patient_list
        if patient.get('age', 0) >= 60  # 使用get避免KeyError
    ]

【性能对比】:
原版: O(n) 但有额外的索引开销
改进版: O(n) 且更高效,测试显示快约30%

【额外建议】:
1. 考虑将60这个阈值作为参数,提高灵活性
2. 可以添加类型提示增强代码可读性
3. 考虑使用filter()函数的替代方案

【类型提示版本】:

from typing import List, Dict, Any

def get_elderly_patients(
    patient_list: List[Dict[str, Any]],
    age_threshold: int = 60
) -> List[Dict[str, Any]]:
    """筛选指定年龄以上的患者"""
    if not patient_list:
        return []

    return [
        patient for patient in patient_list
        if patient.get('age', 0) >= age_threshold
    ]
```

### 策略2: 聚焦特定维度

**Prompt模板**:
```
请重点审查以下代码的[性能/安全性/可读性]:

```python
[代码]
```

找出所有与[维度]相关的问题,并提供优化方案。
```

**实例 - 性能审查**:

**你问**:
```
请重点审查以下代码的性能问题:

```python
def calculate_stats(df):
    ages = []
    for i in range(len(df)):
        ages.append(df.iloc[i]['age'])

    mean_age = sum(ages) / len(ages)

    variance = 0
    for age in ages:
        variance += (age - mean_age) ** 2
    variance = variance / len(ages)

    return mean_age, variance
```

这个函数处理10万行数据时很慢,请找出性能瓶颈并优化。
```

**AI答**:
```
性能审查报告:

【性能瓶颈1: 低效的DataFrame遍历】★★★★★ (最严重)
位置: for i in range(len(df)): ... df.iloc[i]
问题:
- iloc[i]是最慢的DataFrame访问方式
- 每次访问都要定位行,O(n²)复杂度
影响: 10万行数据会执行100亿次操作!

优化: 使用向量化操作
df['age'].tolist() 或 df['age'].values

【性能瓶颈2: 不必要的列表转换】★★★☆☆
位置: ages = [] ... append()
问题: 先转列表再计算,多一次遍历
优化: 直接用pandas方法

【性能瓶颈3: 手动计算统计量】★★★★☆
位置: 手动计算均值和方差
问题: pandas内置方法经过C优化,快10-100倍
优化: 使用df['age'].mean()和df['age'].var()

【性能瓶颈4: 重复计算】★★☆☆☆
位置: (age - mean_age) ** 2
问题: 循环中重复计算,没有必要
优化: 向量化一次性计算

【优化后代码】:

# 版本1: 使用pandas内置方法(最优)
def calculate_stats(df):
    """
    性能: 10万行数据 < 10ms
    """
    return df['age'].mean(), df['age'].var()

# 版本2: 如果必须手动实现
import numpy as np

def calculate_stats_manual(df):
    """
    性能: 10万行数据 < 50ms
    """
    ages = df['age'].values  # NumPy数组,比列表快
    mean_age = ages.mean()
    variance = ((ages - mean_age) ** 2).mean()
    return mean_age, variance

【性能对比】:
原版:    10万行 → ~5000ms  (5秒)
优化版本1: 10万行 → ~8ms    (600倍加速!)
优化版本2: 10万行 → ~45ms   (100倍加速)

【基准测试代码】:

import pandas as pd
import numpy as np
import time

# 创建测试数据
df = pd.DataFrame({'age': np.random.randint(20, 80, 100000)})

# 测试原版
start = time.time()
mean, var = calculate_stats_original(df)
print(f"原版: {(time.time() - start) * 1000:.2f}ms")

# 测试优化版
start = time.time()
mean, var = calculate_stats(df)
print(f"优化版: {(time.time() - start) * 1000:.2f}ms")

【关键优化原则】:
1. 永远不要用iloc[i]遍历DataFrame
2. 优先使用pandas/numpy内置方法
3. 避免Python循环,使用向量化操作
4. 理解复杂度:O(n²) vs O(n)

【额外优化建议】:
1. 如果数据量更大(百万级),考虑使用Dask
2. 可以缓存结果避免重复计算
3. 考虑并行处理(multiprocessing)
```

### 策略3: 安全性审查

**Prompt模板**:
```
请从安全角度审查以下代码,特别关注医疗数据隐私:

```python
[代码]
```

找出:
1. 数据泄露风险
2. 注入攻击风险
3. 访问控制问题
4. 其他安全隐患
```

**实例**:

**你问**:
```
请从安全角度审查以下代码:

```python
def export_patient_data(patient_id, output_file):
    """导出患者数据到文件"""
    conn = sqlite3.connect('hospital.db')
    query = f"SELECT * FROM patients WHERE id = {patient_id}"
    df = pd.read_sql(query, conn)

    # 记录日志
    print(f"导出患者 {patient_id} 的数据到 {output_file}")

    # 保存
    df.to_csv(output_file, index=False)
    conn.close()

    # 发送邮件通知
    send_email(f"患者数据已导出: {output_file}")
```

这是医疗数据,请找出安全风险。
```

**AI答**:
```
🚨 安全审查报告 - 发现严重问题!

【严重问题1: SQL注入风险】★★★★★ (危急!)
位置: query = f"SELECT * FROM patients WHERE id = {patient_id}"
风险:
- 使用字符串拼接构造SQL
- 如果patient_id = "1 OR 1=1",会返回所有患者数据!
- 攻击者可以删除数据: "1; DROP TABLE patients--"

修复:
```python
# ✓ 使用参数化查询
query = "SELECT * FROM patients WHERE id = ?"
df = pd.read_sql(query, conn, params=(patient_id,))
```

【严重问题2: 敏感数据记录到日志】★★★★☆
位置: print(f"导出患者 {patient_id} ...")
风险:
- 患者ID可能是敏感信息
- 日志文件可能被未授权人员访问
- 违反HIPAA/GDPR等隐私法规

修复:
```python
# ✓ 使用脱敏的日志
import logging
logger.info("患者数据导出操作", extra={
    'patient_id_hash': hashlib.sha256(str(patient_id).encode()).hexdigest()[:8],
    'operation': 'export'
})
```

【严重问题3: 未加密的数据导出】★★★★★
位置: df.to_csv(output_file, index=False)
风险:
- CSV明文存储患者所有信息
- 文件可能被未授权访问
- 泄露患者隐私

修复:
```python
# ✓ 加密导出
from cryptography.fernet import Fernet

def export_encrypted(df, output_file, key):
    data = df.to_csv(index=False).encode()
    f = Fernet(key)
    encrypted = f.encrypt(data)
    with open(output_file, 'wb') as file:
        file.write(encrypted)
```

【严重问题4: 缺少访问控制】★★★★☆
位置: 整个函数
风险:
- 任何人调用都能导出数据
- 没有验证调用者权限
- 没有审计记录

修复:
```python
# ✓ 添加权限验证
def export_patient_data(patient_id, output_file, user_id, user_role):
    # 验证权限
    if not has_permission(user_id, user_role, 'export_patient_data'):
        logger.warning(f"未授权访问尝试: user={user_id}")
        raise PermissionError("无权限导出患者数据")

    # 记录审计日志
    audit_log(user_id, 'export', patient_id, output_file)

    # ... 后续操作
```

【严重问题5: 邮件内容暴露路径】★★★☆☆
位置: send_email(f"患者数据已导出: {output_file}")
风险:
- 邮件中包含完整文件路径
- 可能暴露服务器结构
- 邮件可能被拦截

修复:
```python
# ✓ 只发送必要信息
send_email(
    recipient=authorized_email,
    subject="数据导出完成",
    body="您的数据导出请求已完成,请登录系统下载。",
    encrypted=True
)
```

【严重问题6: 缺少输入验证】★★★☆☆
位置: patient_id参数
风险:
- 没有验证patient_id格式
- 可能导致意外错误或攻击

修复:
```python
# ✓ 验证输入
if not isinstance(patient_id, int) or patient_id <= 0:
    raise ValueError("无效的患者ID")
```

【完整的安全版本】:

import sqlite3
import pandas as pd
import logging
from cryptography.fernet import Fernet
import hashlib

def export_patient_data_secure(
    patient_id: int,
    output_file: str,
    user_id: str,
    user_role: str,
    encryption_key: bytes
):
    """
    安全导出患者数据

    Args:
        patient_id: 患者ID
        output_file: 输出文件路径
        user_id: 操作用户ID
        user_role: 用户角色
        encryption_key: 加密密钥

    Raises:
        PermissionError: 无权限
        ValueError: 参数无效
    """
    # 1. 输入验证
    if not isinstance(patient_id, int) or patient_id <= 0:
        raise ValueError("无效的患者ID")

    # 2. 权限验证
    if not has_permission(user_id, user_role, 'export_patient_data'):
        logger.warning(
            "未授权访问尝试",
            extra={'user': user_id, 'action': 'export'}
        )
        raise PermissionError("无权限导出患者数据")

    # 3. 记录审计日志(脱敏)
    audit_log(
        user_id=user_id,
        action='export_patient_data',
        patient_id_hash=hashlib.sha256(
            str(patient_id).encode()
        ).hexdigest()
    )

    try:
        # 4. 安全的数据库查询(参数化)
        conn = sqlite3.connect('hospital.db')
        query = "SELECT * FROM patients WHERE id = ?"
        df = pd.read_sql(query, conn, params=(patient_id,))

        # 5. 检查是否存在
        if df.empty:
            raise ValueError("患者不存在")

        # 6. 加密导出
        data = df.to_csv(index=False).encode()
        f = Fernet(encryption_key)
        encrypted = f.encrypt(data)

        with open(output_file, 'wb') as file:
            file.write(encrypted)

        # 7. 安全的通知(不含敏感信息)
        send_secure_notification(
            user_id=user_id,
            message="数据导出完成,请登录系统查看。"
        )

    except Exception as e:
        logger.error(f"数据导出失败: {str(e)}")
        raise
    finally:
        conn.close()

【合规性检查清单】:
- [x] HIPAA合规: PHI加密存储
- [x] GDPR合规: 审计日志、访问控制
- [x] 最小权限原则: 权限验证
- [x] 数据泄露防护: 加密、脱敏
- [x] 审计追踪: 完整操作日志

【推荐阅读】:
- OWASP Top 10: https://owasp.org/www-project-top-ten/
- HIPAA安全规则: https://www.hhs.gov/hipaa/
- Python安全最佳实践: https://python.readthedocs.io/en/stable/library/security_warnings.html
```

### 策略4: 对比式审查

**Prompt模板**:
```
我写了两种实现方式,请对比分析哪个更好:

方法A:
```python
[代码A]
```

方法B:
```python
[代码B]
```

从[正确性/性能/可读性]角度对比,给出推荐。
```

## 代码审查的最佳实践

### 1. 审查前的准备

**提供充分的上下文**:
```
❌ 不好:
"审查这段代码: [代码]"

✅ 好:
"这段代码用于[目的],处理[数据量],
部署在[环境],性能要求[X],
请审查并找出问题。"
```

### 2. 分阶段审查

**第一轮: 快速审查**
```
请快速审查,找出明显的bug和性能问题。
```

**第二轮: 深度审查**
```
请深度审查代码风格、最佳实践、边界情况处理。
```

**第三轮: 安全审查**
```
这是处理医疗数据的代码,请进行安全审查。
```

### 3. 要求具体的改进

**好的Prompt**:
```
审查后:
1. 列出所有问题,按严重程度排序
2. 对每个问题给出具体的修改代码
3. 解释为什么要这样改
4. 给出改进前后的对比
```

## 实战演练

### 练习1: 全面审查

**你的代码**:
```python
def process_patients(filename):
    data = []
    f = open(filename, 'r')
    for line in f:
        parts = line.split(',')
        if int(parts[2]) > 60:
            data.append(parts)
    return data
```

**Prompt**:
```
全面审查这段代码,找出所有问题并给出改进版本。
```

### 练习2: 性能优化审查

**你的代码**:
```python
def find_duplicates(patient_ids):
    duplicates = []
    for i in range(len(patient_ids)):
        for j in range(i + 1, len(patient_ids)):
            if patient_ids[i] == patient_ids[j]:
                if patient_ids[i] not in duplicates:
                    duplicates.append(patient_ids[i])
    return duplicates
```

**Prompt**:
```
这段代码处理100万个ID时很慢,请审查性能并优化。
```

### 练习3: 安全审查

**你的代码**:
```python
def login(username, password):
    query = f"SELECT * FROM users WHERE username='{username}' AND password='{password}'"
    result = db.execute(query)
    return result.fetchone() is not None
```

**Prompt**:
```
审查这段登录代码的安全性,找出所有安全隐患。
```

## 检查清单

- [ ] 理解代码审查的5个维度
- [ ] 掌握全面审查的Prompt格式
- [ ] 会针对特定维度(性能/安全)进行审查
- [ ] 知道如何要求AI对比不同实现
- [ ] 了解医疗数据处理的安全要求
- [ ] 养成代码完成后主动审查的习惯
- [ ] 能理解AI的审查建议并应用
- [ ] 知道何时需要人工复审

## 下一步

- **6.5 实战**: 用AI学习新的Python库
- **第7章**: AI编程工具(Copilot, Cursor)
- **第8章**: AI辅助开发完整流程

## Prompt模板速查

### 全面审查
```
审查代码:[代码]
维度:正确性、性能、可读性、安全性、最佳实践
给出:问题列表+改进代码+解释
```

### 性能审查
```
重点审查性能:[代码]
数据量:[X]
找出瓶颈,给出优化方案和性能对比
```

### 安全审查
```
安全审查(医疗数据):[代码]
检查:SQL注入、数据泄露、访问控制、加密
```

### 对比审查
```
对比:[代码A] vs [代码B]
角度:[性能/可读性/安全]
给出推荐+理由
```

## 代码质量检查工具

**自动化工具**:
- `pylint`: 代码质量检查
- `black`: 代码格式化
- `mypy`: 类型检查
- `bandit`: 安全漏洞扫描

**使用方法**:
```bash
pip install pylint black mypy bandit

# 检查代码质量
pylint your_script.py

# 格式化代码
black your_script.py

# 类型检查
mypy your_script.py

# 安全扫描
bandit -r your_project/
```

**结合AI**: 先用工具扫描,再把结果交给AI解释和修复!

## 推荐资源

- Clean Code (Python版): 代码整洁之道
- Effective Python: Python最佳实践
- OWASP Top 10: 安全漏洞Top 10
- PEP 8: Python代码风格指南
