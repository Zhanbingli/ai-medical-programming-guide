# 9.3 提取PDF文献的元数据

## 问题场景

**下载的PDF文件**:
```
下载(1).pdf
下载(2).pdf
PMC12345678.pdf
```

**如何自动提取**:
- 标题
- 作者
- DOI
- 发表年份
- 期刊名称

## 用AI开发PDF元数据提取工具

### 需求描述

**向AI提问**:
```
我需要一个Python脚本:

输入: 文件夹中的PDF文献
功能:
1. 从PDF第一页提取DOI
2. 根据DOI获取完整文献信息(CrossRef API)
3. 提取备选信息(如果没有DOI)

输出: Excel表格,包含所有文献的元数据

要求:
- 使用pdfplumber提取文本
- 正则表达式匹配DOI
- 异常处理(PDF加密、无DOI等)
```

### AI生成代码

```python
"""
PDF文献元数据提取工具
"""

import pdfplumber
import pandas as pd
import requests
import re
from pathlib import Path
from tqdm import tqdm
import time

def extract_doi_from_pdf(pdf_path):
    """
    从PDF提取DOI

    Args:
        pdf_path: PDF文件路径

    Returns:
        DOI字符串,未找到则返回None
    """
    try:
        with pdfplumber.open(pdf_path) as pdf:
            # 只检查前3页
            for page in pdf.pages[:3]:
                text = page.extract_text()

                if not text:
                    continue

                # DOI正则表达式
                doi_pattern = r'10\.\d{4,}/[^\s]+'
                match = re.search(doi_pattern, text)

                if match:
                    doi = match.group(0)
                    # 清理末尾的标点符号
                    doi = re.sub(r'[.,;)\]]+$', '', doi)
                    return doi

        return None

    except Exception as e:
        print(f"⚠️  读取PDF失败: {e}")
        return None

def get_metadata_from_doi(doi):
    """
    根据DOI获取文献信息(CrossRef API)

    Args:
        doi: DOI字符串

    Returns:
        文献信息字典
    """
    url = f"https://api.crossref.org/works/{doi}"

    try:
        response = requests.get(url, timeout=10)

        if response.status_code == 200:
            data = response.json()['message']

            # 提取作者
            authors = []
            if 'author' in data:
                for author in data['author'][:3]:  # 只取前3位作者
                    given = author.get('given', '')
                    family = author.get('family', '')
                    authors.append(f"{family} {given}".strip())

            author_str = '; '.join(authors)
            if len(data.get('author', [])) > 3:
                author_str += ' et al.'

            # 提取年份
            year = ''
            if 'published' in data:
                date_parts = data['published'].get('date-parts', [[]])[0]
                if date_parts:
                    year = str(date_parts[0])

            return {
                'Title': data.get('title', [''])[0],
                'Authors': author_str,
                'Journal': data.get('container-title', [''])[0],
                'Year': year,
                'DOI': doi,
                'Type': data.get('type', ''),
                'Volume': data.get('volume', ''),
                'Issue': data.get('issue', ''),
                'Pages': data.get('page', '')
            }

        return None

    except Exception as e:
        print(f"⚠️  API请求失败: {e}")
        return None

def extract_title_from_pdf(pdf_path):
    """
    从PDF提取标题(备选方案)

    通常第一页最大字号的文本就是标题
    """
    try:
        with pdfplumber.open(pdf_path) as pdf:
            first_page = pdf.pages[0]
            text = first_page.extract_text()

            if text:
                # 取前几行作为标题候选
                lines = [line.strip() for line in text.split('\n') if line.strip()]
                if lines:
                    return lines[0][:200]  # 限制长度

        return "Unknown Title"

    except:
        return "Unknown Title"

def process_pdf_folder(folder_path, output_file='literature_metadata.xlsx'):
    """
    批量处理文件夹中的PDF

    Args:
        folder_path: PDF文件夹路径
        output_file: 输出Excel文件名
    """
    print("=" * 60)
    print("PDF文献元数据提取工具")
    print("=" * 60)

    folder = Path(folder_path)
    pdf_files = list(folder.glob('*.pdf'))

    if not pdf_files:
        print("未找到PDF文件")
        return

    print(f"\n找到{len(pdf_files)}个PDF文件")

    results = []

    for pdf_file in tqdm(pdf_files, desc="处理PDF"):
        file_info = {
            'Filename': pdf_file.name,
            'Title': '',
            'Authors': '',
            'Journal': '',
            'Year': '',
            'DOI': '',
            'Type': '',
            'Volume': '',
            'Issue': '',
            'Pages': '',
            'Status': ''
        }

        # 1. 尝试提取DOI
        doi = extract_doi_from_pdf(pdf_file)

        if doi:
            file_info['DOI'] = doi

            # 2. 根据DOI获取元数据
            metadata = get_metadata_from_doi(doi)

            if metadata:
                file_info.update(metadata)
                file_info['Status'] = '✓ DOI获取成功'
            else:
                # DOI无效,提取标题
                file_info['Title'] = extract_title_from_pdf(pdf_file)
                file_info['Status'] = '⚠️  DOI无效'
        else:
            # 3. 没有DOI,只提取标题
            file_info['Title'] = extract_title_from_pdf(pdf_file)
            file_info['Status'] = '⚠️  未找到DOI'

        results.append(file_info)

        # 避免请求过快
        time.sleep(0.2)

    # 保存为Excel
    df = pd.DataFrame(results)

    # 重排列顺序
    columns = ['Filename', 'Status', 'Title', 'Authors', 'Journal',
               'Year', 'DOI', 'Type', 'Volume', 'Issue', 'Pages']
    df = df[columns]

    df.to_excel(output_file, index=False, engine='openpyxl')

    # 统计
    success_count = sum(1 for r in results if 'DOI获取成功' in r['Status'])
    print(f"\n✓ 处理完成!")
    print(f"  - 成功获取元数据: {success_count}/{len(pdf_files)}")
    print(f"  - 结果保存至: {output_file}")

def main():
    """主程序"""
    import sys

    if len(sys.argv) < 2:
        print("用法: python extract_metadata.py <PDF文件夹路径>")
        print("\n示例: python extract_metadata.py ./papers")
        return

    folder_path = sys.argv[1]
    process_pdf_folder(folder_path)

if __name__ == "__main__":
    main()
```

### 使用方法

#### 1. 安装依赖

```bash
pip install pdfplumber pandas openpyxl requests tqdm
```

#### 2. 运行脚本

```bash
python extract_metadata.py ./papers
```

**运行示例**:
```
============================================================
PDF文献元数据提取工具
============================================================

找到15个PDF文件
处理PDF: 100%|██████████| 15/15 [00:25<00:00]

✓ 处理完成!
  - 成功获取元数据: 12/15
  - 结果保存至: literature_metadata.xlsx
```

#### 3. 查看结果

Excel表格内容:

| Filename | Status | Title | Authors | Journal | Year | DOI |
|----------|--------|-------|---------|---------|------|-----|
| paper1.pdf | ✓ DOI获取成功 | Hypertension Treatment | Smith J et al. | Nature | 2024 | 10.1038/xxx |
| 下载(1).pdf | ⚠️  未找到DOI | Diabetes Research | - | - | - | - |

### 进阶功能

#### 功能1: 自动重命名文件

**向AI请求**:
```
在提取元数据后,自动重命名PDF为:
格式: {第一作者}_{年份}_{标题前20字符}.pdf
```

**AI添加代码**:
```python
def rename_pdf(old_path, metadata):
    """根据元数据重命名PDF"""
    if not metadata.get('Authors') or not metadata.get('Year'):
        return  # 信息不全,不重命名

    # 提取第一作者姓氏
    first_author = metadata['Authors'].split(';')[0].split()[0]
    year = metadata['Year']
    title = metadata['Title'][:20].replace('/', '_')

    # 清理非法字符
    new_name = f"{first_author}_{year}_{title}.pdf"
    new_name = re.sub(r'[<>:"/\\|?*]', '', new_name)

    new_path = old_path.parent / new_name

    # 避免覆盖
    if new_path.exists():
        new_name = f"{first_author}_{year}_{title}_copy.pdf"
        new_path = old_path.parent / new_name

    old_path.rename(new_path)
    print(f"  重命名: {old_path.name} → {new_name}")
```

#### 功能2: 处理加密PDF

```python
def extract_doi_from_pdf(pdf_path):
    """改进版:处理加密PDF"""
    try:
        with pdfplumber.open(pdf_path, password='') as pdf:
            # ... 其余代码
    except Exception as e:
        if 'password' in str(e).lower():
            print(f"⚠️  {pdf_path.name} 已加密,需要密码")
        else:
            print(f"⚠️  读取失败: {e}")
        return None
```

### 常见问题

**Q: CrossRef API请求失败?**
```python
# 添加重试机制
import time

def get_metadata_from_doi(doi, retries=3):
    for i in range(retries):
        try:
            response = requests.get(url, timeout=10)
            if response.status_code == 200:
                return parse_response(response)
        except:
            if i < retries - 1:
                time.sleep(2)  # 等待2秒重试
                continue
    return None
```

**Q: 提取的DOI不准确?**
```python
# 改进正则表达式
doi_pattern = r'(?:doi:|DOI:)?\s*(10\.\d{4,}/[^\s]+)'

# 验证DOI格式
def validate_doi(doi):
    """验证DOI是否有效"""
    return re.match(r'^10\.\d{4,}/[^\s]+$', doi) is not None
```

**Q: 想导出BibTeX格式?**
```python
def export_bibtex(metadata_list, output_file='references.bib'):
    """导出为BibTeX格式"""
    with open(output_file, 'w', encoding='utf-8') as f:
        for meta in metadata_list:
            if not meta.get('DOI'):
                continue

            # 生成引用key
            key = f"{meta['Authors'].split()[0]}{meta['Year']}"

            f.write(f"@article{{{key},\n")
            f.write(f"  title={{{meta['Title']}}},\n")
            f.write(f"  author={{{meta['Authors']}}},\n")
            f.write(f"  journal={{{meta['Journal']}}},\n")
            f.write(f"  year={{{meta['Year']}}},\n")
            f.write(f"  doi={{{meta['DOI']}}}\n")
            f.write("}\n\n")
```

## 检查清单

- [ ] 能成功从PDF提取DOI
- [ ] CrossRef API正常工作
- [ ] 处理了加密和损坏的PDF
- [ ] 导出的Excel包含完整信息
- [ ] 理解DOI的作用和格式

## 下一步

[9.4 文献去重与智能分类](9.4-deduplication.md) - 识别重复文献并自动分类
