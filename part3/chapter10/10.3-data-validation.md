# 10.3 数据验证与质控

## 为什么需要数据验证?

### 真实案例

**临床试验数据录入错误**:
```
患者001: 年龄250岁  ← 明显错误!
患者002: 收缩压80, 舒张压120  ← 倒置了!
患者003: 入组日期2025-01-01, 随访日期2024-01-01  ← 时间倒流!
患者004: 体重15kg (成年人)  ← 不可能!
```

**后果**:
- ❌ 统计结果错误
- ❌ 论文被拒
- ❌ 浪费时间重新整理
- ❌ 影响科研声誉

**解决方案**: 自动化数据验证

## 数据质量标准

### 六大质控维度

| 维度 | 检查内容 | 示例 |
|------|---------|------|
| **完整性** | 必填字段无缺失 | 患者ID、分组不能为空 |
| **准确性** | 数值在合理范围 | 年龄18-120岁 |
| **一致性** | 逻辑关系正确 | 收缩压 > 舒张压 |
| **唯一性** | 无重复记录 | 患者ID唯一 |
| **时效性** | 时间顺序正确 | 入组日期 < 随访日期 |
| **格式性** | 格式符合规范 | 日期YYYY-MM-DD |

## 用AI开发数据验证工具

### 需求描述

**向AI提问**:
```
我需要一个临床数据验证工具,功能包括:

1. 必填字段检查(患者ID、分组、性别不能为空)
2. 范围验证:
   - 年龄: 18-120岁
   - 收缩压: 80-250 mmHg
   - 舒张压: 40-150 mmHg
   - BMI: 10-60
3. 逻辑验证:
   - 收缩压 > 舒张压
   - 随访日期 > 入组日期
   - 治疗后血压 与 基线血压 可对比
4. 唯一性验证:
   - 患者ID无重复
5. 异常检测:
   - 使用IQR方法检测极端值

输出:
- Excel格式的验证报告
- 标记每个错误的具体位置
- 生成问题汇总表
```

### AI生成代码

```python
"""
临床数据验证工具
"""

import pandas as pd
import numpy as np
from datetime import datetime

class DataValidator:
    """数据验证器"""

    def __init__(self, data_file):
        """
        初始化

        Args:
            data_file: Excel数据文件
        """
        self.df = pd.read_excel(data_file)
        self.errors = []  # 错误列表
        self.warnings = []  # 警告列表

    def check_required_fields(self, required_columns):
        """
        检查必填字段

        Args:
            required_columns: 必填列名列表
        """
        print("检查必填字段...")

        for col in required_columns:
            if col not in self.df.columns:
                self.errors.append({
                    'Type': 'Missing Column',
                    'Column': col,
                    'Row': 'All',
                    'Value': '',
                    'Message': f'缺少必填列: {col}'
                })
                continue

            # 检查缺失值
            missing_mask = self.df[col].isna()
            missing_rows = self.df[missing_mask].index.tolist()

            for row in missing_rows:
                self.errors.append({
                    'Type': 'Missing Value',
                    'Column': col,
                    'Row': row + 2,  # Excel行号(从1开始,表头占1行)
                    'Value': 'NA',
                    'Message': f'{col}不能为空'
                })

        return self

    def check_range(self, column, min_val, max_val, name=None):
        """
        检查数值范围

        Args:
            column: 列名
            min_val: 最小值
            max_val: 最大值
            name: 显示名称
        """
        name = name or column
        print(f"检查{name}范围...")

        if column not in self.df.columns:
            return self

        # 只检查非缺失值
        valid_data = self.df[column].dropna()

        # 检查范围
        out_of_range = valid_data[(valid_data < min_val) | (valid_data > max_val)]

        for idx, value in out_of_range.items():
            self.errors.append({
                'Type': 'Out of Range',
                'Column': column,
                'Row': idx + 2,
                'Value': value,
                'Message': f'{name}应在{min_val}-{max_val}之间,实际值:{value}'
            })

        return self

    def check_logic(self, column1, operator, column2, message):
        """
        检查逻辑关系

        Args:
            column1: 列1
            operator: 运算符('>', '<', '>=', '<=', '==', '!=')
            column2: 列2或具体值
            message: 错误消息
        """
        print(f"检查逻辑: {column1} {operator} {column2}...")

        if column1 not in self.df.columns:
            return self

        # 获取数据
        data1 = self.df[column1]

        if isinstance(column2, str) and column2 in self.df.columns:
            data2 = self.df[column2]
        else:
            data2 = column2

        # 根据运算符检查
        if operator == '>':
            invalid_mask = ~(data1 > data2)
        elif operator == '<':
            invalid_mask = ~(data1 < data2)
        elif operator == '>=':
            invalid_mask = ~(data1 >= data2)
        elif operator == '<=':
            invalid_mask = ~(data1 <= data2)
        elif operator == '==':
            invalid_mask = ~(data1 == data2)
        elif operator == '!=':
            invalid_mask = ~(data1 != data2)
        else:
            return self

        # 排除缺失值
        if isinstance(data2, pd.Series):
            invalid_mask = invalid_mask & data1.notna() & data2.notna()
        else:
            invalid_mask = invalid_mask & data1.notna()

        # 记录错误
        invalid_rows = self.df[invalid_mask]

        for idx, row in invalid_rows.iterrows():
            val1 = row[column1]
            val2 = row[column2] if isinstance(column2, str) else column2

            self.errors.append({
                'Type': 'Logic Error',
                'Column': f'{column1} vs {column2}',
                'Row': idx + 2,
                'Value': f'{val1} {operator} {val2}',
                'Message': message
            })

        return self

    def check_unique(self, column):
        """
        检查唯一性

        Args:
            column: 列名
        """
        print(f"检查{column}唯一性...")

        if column not in self.df.columns:
            return self

        # 查找重复
        duplicates = self.df[self.df[column].duplicated(keep=False)]

        for idx, row in duplicates.iterrows():
            self.errors.append({
                'Type': 'Duplicate',
                'Column': column,
                'Row': idx + 2,
                'Value': row[column],
                'Message': f'{column}重复: {row[column]}'
            })

        return self

    def check_date_logic(self, date1_col, date2_col, relationship='<'):
        """
        检查日期逻辑关系

        Args:
            date1_col: 日期列1
            date2_col: 日期列2
            relationship: 关系('<'表示date1应早于date2)
        """
        print(f"检查日期关系: {date1_col} {relationship} {date2_col}...")

        if date1_col not in self.df.columns or date2_col not in self.df.columns:
            return self

        # 转换为日期类型
        date1 = pd.to_datetime(self.df[date1_col], errors='coerce')
        date2 = pd.to_datetime(self.df[date2_col], errors='coerce')

        # 检查逻辑
        if relationship == '<':
            invalid_mask = ~(date1 < date2)
        elif relationship == '>':
            invalid_mask = ~(date1 > date2)
        else:
            return self

        # 排除缺失值
        invalid_mask = invalid_mask & date1.notna() & date2.notna()

        # 记录错误
        for idx in self.df[invalid_mask].index:
            self.errors.append({
                'Type': 'Date Logic Error',
                'Column': f'{date1_col} vs {date2_col}',
                'Row': idx + 2,
                'Value': f'{date1[idx]} vs {date2[idx]}',
                'Message': f'{date1_col}应早于{date2_col}'
            })

        return self

    def detect_outliers(self, column, method='iqr'):
        """
        检测异常值

        Args:
            column: 列名
            method: 'iqr'四分位数 或 'zscore'z分数
        """
        print(f"检测{column}异常值...")

        if column not in self.df.columns:
            return self

        data = self.df[column].dropna()

        if method == 'iqr':
            Q1 = data.quantile(0.25)
            Q3 = data.quantile(0.75)
            IQR = Q3 - Q1

            lower = Q1 - 1.5 * IQR
            upper = Q3 + 1.5 * IQR

            outlier_mask = (self.df[column] < lower) | (self.df[column] > upper)

        elif method == 'zscore':
            mean = data.mean()
            std = data.std()

            z_scores = np.abs((self.df[column] - mean) / std)
            outlier_mask = z_scores > 3

        else:
            return self

        # 排除缺失值
        outlier_mask = outlier_mask & self.df[column].notna()

        # 记录警告(异常值可能是真实的)
        for idx in self.df[outlier_mask].index:
            self.warnings.append({
                'Type': 'Potential Outlier',
                'Column': column,
                'Row': idx + 2,
                'Value': self.df.loc[idx, column],
                'Message': f'{column}可能异常(请人工核实)'
            })

        return self

    def validate_all(self):
        """执行完整验证"""
        print("=" * 60)
        print("数据验证工具")
        print("=" * 60)

        # 1. 必填字段
        required = ['患者ID', '性别', '治疗分组']
        self.check_required_fields(required)

        # 2. 范围验证
        self.check_range('年龄', 18, 120, '年龄')
        self.check_range('收缩压', 80, 250, '收缩压')
        self.check_range('舒张压', 40, 150, '舒张压')

        if 'BMI' in self.df.columns:
            self.check_range('BMI', 10, 60, 'BMI')

        # 3. 逻辑验证
        self.check_logic('收缩压', '>', '舒张压', '收缩压应大于舒张压')

        # 4. 日期验证
        if '入组日期' in self.df.columns and '随访日期' in self.df.columns:
            self.check_date_logic('入组日期', '随访日期', '<')

        # 5. 唯一性
        self.check_unique('患者ID')

        # 6. 异常值检测
        for col in ['年龄', '收缩压', '舒张压', 'BMI']:
            if col in self.df.columns:
                self.detect_outliers(col)

        print("\n" + "=" * 60)
        print("验证完成!")
        print("=" * 60)

        return self

    def generate_report(self):
        """生成验证报告"""
        print(f"\n发现 {len(self.errors)} 个错误")
        print(f"发现 {len(self.warnings)} 个警告\n")

        if self.errors:
            print("错误列表(前10条):")
            print("-" * 60)
            for error in self.errors[:10]:
                print(f"[行{error['Row']}] {error['Column']}: {error['Message']}")

        if self.warnings:
            print(f"\n警告列表(前10条):")
            print("-" * 60)
            for warning in self.warnings[:10]:
                print(f"[行{warning['Row']}] {warning['Column']}: {warning['Message']}")

    def save_report(self, output_file='validation_report.xlsx'):
        """保存验证报告到Excel"""

        with pd.ExcelWriter(output_file, engine='openpyxl') as writer:
            # 错误表
            if self.errors:
                df_errors = pd.DataFrame(self.errors)
                df_errors.to_excel(writer, sheet_name='Errors', index=False)

            # 警告表
            if self.warnings:
                df_warnings = pd.DataFrame(self.warnings)
                df_warnings.to_excel(writer, sheet_name='Warnings', index=False)

            # 汇总表
            summary = {
                '验证项': ['错误总数', '警告总数', '数据行数'],
                '数量': [len(self.errors), len(self.warnings), len(self.df)]
            }
            df_summary = pd.DataFrame(summary)
            df_summary.to_excel(writer, sheet_name='Summary', index=False)

        print(f"\n✓ 验证报告已保存: {output_file}")

def main():
    """主程序"""
    import sys

    if len(sys.argv) < 2:
        print("用法: python data_validator.py <数据文件> [报告文件]")
        return

    data_file = sys.argv[1]
    report_file = sys.argv[2] if len(sys.argv) > 2 else 'validation_report.xlsx'

    # 验证
    validator = DataValidator(data_file)
    validator.validate_all()

    # 生成报告
    validator.generate_report()
    validator.save_report(report_file)

if __name__ == "__main__":
    main()
```

### 使用方法

```bash
python data_validator.py trial_data_clean.xlsx validation_report.xlsx
```

**输出示例**:
```
============================================================
数据验证工具
============================================================
检查必填字段...
检查年龄范围...
检查收缩压范围...
检查舒张压范围...
检查BMI范围...
检查逻辑: 收缩压 > 舒张压...
检查日期关系: 入组日期 < 随访日期...
检查患者ID唯一性...
检测年龄异常值...
检测收缩压异常值...
检测舒张压异常值...
检测BMI异常值...

============================================================
验证完成!
============================================================

发现 15 个错误
发现 8 个警告

错误列表(前10条):
------------------------------------------------------------
[行25] 性别: 性别不能为空
[行37] 收缩压: 收缩压应在80-250之间,实际值:300
[行45] 收缩压 vs 舒张压: 收缩压应大于舒张压
[行58] 患者ID: 患者ID重复: P001
[行72] 入组日期 vs 随访日期: 入组日期应早于随访日期
...

警告列表(前10条):
------------------------------------------------------------
[行12] 年龄: 年龄可能异常(请人工核实)
[行33] BMI: BMI可能异常(请人工核实)
...

✓ 验证报告已保存: validation_report.xlsx
```

## 自定义验证规则

### 场景: 临床试验特定规则

**向AI请求**:
```
添加临床试验专用验证:
1. 不良事件严重程度必须是1-5级
2. 治疗分组必须是"A药"或"B药"
3. 如果有不良事件,必须填写发生日期
4. 血糖>11.1 mmol/L的患者必须标记为"糖尿病"
```

**AI生成代码**:
```python
def check_adverse_event_severity(self):
    """检查不良事件严重程度"""
    if '不良事件严重程度' not in self.df.columns:
        return self

    valid_levels = [1, 2, 3, 4, 5]

    invalid = self.df[
        ~self.df['不良事件严重程度'].isin(valid_levels) &
        self.df['不良事件严重程度'].notna()
    ]

    for idx, row in invalid.iterrows():
        self.errors.append({
            'Type': 'Invalid Value',
            'Column': '不良事件严重程度',
            'Row': idx + 2,
            'Value': row['不良事件严重程度'],
            'Message': '严重程度必须是1-5级'
        })

    return self

def check_conditional_required(self, condition_col, condition_val,
                               required_col):
    """
    条件必填检查

    如果condition_col=condition_val,则required_col必填
    """
    mask = (self.df[condition_col] == condition_val) & \
           (self.df[required_col].isna())

    for idx in self.df[mask].index:
        self.errors.append({
            'Type': 'Conditional Missing',
            'Column': required_col,
            'Row': idx + 2,
            'Value': 'NA',
            'Message': f'当{condition_col}={condition_val}时,{required_col}必填'
        })

    return self
```

## 检查清单

- [ ] 必填字段都已验证
- [ ] 数值范围合理
- [ ] 逻辑关系正确
- [ ] 无重复数据
- [ ] 日期顺序正确
- [ ] 异常值已标记
- [ ] 生成了验证报告

## 下一步

[10.4 描述性统计分析](10.4-descriptive-stats.md) - 基础统计分析
