# 3.5 必备标准库

> Python标准库 = 开箱即用的工具箱,无需安装,import即可使用

## 为什么学习标准库?

```
Python哲学: "Batteries Included" (自带电池)

意思: 标准库功能强大,满足大部分需求
好处: 不用重复造轮子,提高开发效率
```

## 1. os - 文件路径操作

### 1.1 路径操作

```python
import os

# 获取当前工作目录
current_dir = os.getcwd()
print(f"当前目录: {current_dir}")

# 列出目录内容
files = os.listdir(".")  # "." 表示当前目录
print(f"文件列表: {files}")

# 创建目录
os.mkdir("patient_data")  # 创建单层目录
os.makedirs("data/2025/01", exist_ok=True)  # 创建多层目录,exist_ok避免已存在时报错

# 删除目录
os.rmdir("patient_data")  # 删除空目录
# os.removedirs("data/2025/01")  # 删除多层空目录

# 删除文件
os.remove("temp.txt")

# 重命名
os.rename("old_name.txt", "new_name.txt")

# 检查路径是否存在
if os.path.exists("patients.csv"):
    print("文件存在")

# 检查是文件还是目录
if os.path.isfile("data.csv"):
    print("是文件")
if os.path.isdir("data"):
    print("是目录")
```

### 1.2 路径拼接(跨平台)

```python
import os

# ❌ 不好的方式(Windows和Linux路径分隔符不同)
path = "data" + "/" + "patients.csv"  # 在Windows上可能有问题

# ✅ 好的方式(自动处理分隔符)
path = os.path.join("data", "patients.csv")
# Windows: data\patients.csv
# Linux/Mac: data/patients.csv

# 组合多个路径
path = os.path.join("data", "2025", "01", "patients.csv")

# 获取文件名和目录
full_path = "/Users/doctor/data/patients.csv"
dir_name = os.path.dirname(full_path)  # /Users/doctor/data
file_name = os.path.basename(full_path)  # patients.csv
name, ext = os.path.splitext(file_name)  # ("patients", ".csv")

# 获取绝对路径
abs_path = os.path.abspath("patients.csv")
```

### 1.3 医学场景示例

```python
import os

def organize_dicom_files(source_dir):
    """整理DICOM文件到按日期分类的文件夹"""

    # 确保源目录存在
    if not os.path.exists(source_dir):
        print(f"错误: 目录{source_dir}不存在")
        return

    # 遍历文件
    for filename in os.listdir(source_dir):
        if filename.endswith(".dcm"):
            # 从文件名提取日期 (假设格式: YYYYMMDD_序号.dcm)
            date_str = filename[:8]  # 20250115
            year = date_str[:4]
            month = date_str[4:6]

            # 创建目标目录
            target_dir = os.path.join(source_dir, year, month)
            os.makedirs(target_dir, exist_ok=True)

            # 移动文件
            old_path = os.path.join(source_dir, filename)
            new_path = os.path.join(target_dir, filename)
            os.rename(old_path, new_path)
            print(f"已移动: {filename} -> {target_dir}")

# 使用
organize_dicom_files("DICOM_files")
```

## 2. datetime - 日期时间处理

### 2.1 基本用法

```python
from datetime import datetime, date, time, timedelta

# 获取当前时间
now = datetime.now()
print(now)  # 2025-01-15 10:30:45.123456

today = date.today()
print(today)  # 2025-01-15

# 创建特定日期
birth_date = date(1980, 3, 15)
appointment = datetime(2025, 1, 20, 14, 30)  # 2025-01-20 14:30

# 格式化输出
print(now.strftime("%Y年%m月%d日"))  # 2025年01月15日
print(now.strftime("%Y-%m-%d %H:%M:%S"))  # 2025-01-15 10:30:45
print(now.strftime("%Y/%m/%d"))  # 2025/01/15

# 解析字符串为日期
date_str = "2025-01-15"
date_obj = datetime.strptime(date_str, "%Y-%m-%d")

# 日期计算
tomorrow = today + timedelta(days=1)
next_week = today + timedelta(weeks=1)
three_months_later = today + timedelta(days=90)

# 日期差
last_visit = date(2024, 12, 15)
days_since = (today - last_visit).days
print(f"距离上次就诊{days_since}天")
```

### 2.2 医学场景示例

```python
from datetime import datetime, timedelta

class PatientFollowup:
    """患者随访管理"""

    def __init__(self, patient_name, last_visit_date):
        self.patient_name = patient_name
        self.last_visit_date = datetime.strptime(last_visit_date, "%Y-%m-%d")

    def next_followup_date(self, interval_days=90):
        """计算下次随访日期"""
        return self.last_visit_date + timedelta(days=interval_days)

    def days_until_followup(self):
        """距离下次随访的天数"""
        next_date = self.next_followup_date()
        today = datetime.now()
        days = (next_date - today).days
        return days

    def is_overdue(self):
        """是否逾期"""
        return self.days_until_followup() < 0

# 使用
patient = PatientFollowup("张三", "2024-10-15")
print(f"下次随访日期: {patient.next_followup_date().strftime('%Y-%m-%d')}")
print(f"距离随访: {patient.days_until_followup()}天")

if patient.is_overdue():
    print("⚠️ 已逾期,请尽快随访!")
```

## 3. json - 数据交换格式

### 3.1 基本用法

```python
import json

# Python对象 → JSON字符串
patient = {
    "name": "张三",
    "age": 45,
    "diagnosis": "高血压",
    "medications": ["阿司匹林", "氯沙坦"]
}

json_str = json.dumps(patient, ensure_ascii=False, indent=2)
print(json_str)

# JSON字符串 → Python对象
json_data = '{"name": "李四", "age": 52}'
patient_obj = json.loads(json_data)
print(patient_obj["name"])  # 李四

# 保存到文件
with open("patient.json", "w", encoding="utf-8") as f:
    json.dump(patient, f, ensure_ascii=False, indent=2)

# 从文件读取
with open("patient.json", "r", encoding="utf-8") as f:
    patient_data = json.load(f)
    print(patient_data)
```

### 3.2 医学场景:配置文件

```python
import json

# 保存系统配置
config = {
    "hospital_name": "XX医院",
    "department": "心内科",
    "followup_intervals": {
        "良好": 90,
        "欠佳": 30,
        "新诊断": 14
    },
    "alert_days": 7,
    "sms_template": "{name}您好,您的随访将在{days}天后到期"
}

with open("config.json", "w", encoding="utf-8") as f:
    json.dump(config, f, ensure_ascii=False, indent=2)

# 读取配置
with open("config.json", "r", encoding="utf-8") as f:
    config = json.load(f)
    print(f"科室: {config['department']}")
    print(f"随访间隔: {config['followup_intervals']}")
```

## 4. random - 随机数生成

### 4.1 基本用法

```python
import random

# 随机整数
dice = random.randint(1, 6)  # 1到6之间(包含)

# 随机浮点数
temperature = random.uniform(36.0, 37.5)  # 36.0到37.5之间

# 从列表随机选择
medications = ["阿司匹林", "氯吡格雷", "替格瑞洛"]
choice = random.choice(medications)

# 随机打乱列表
patient_ids = ["P001", "P002", "P003", "P004"]
random.shuffle(patient_ids)  # 原地打乱

# 随机抽样(不放回)
sample = random.sample(patient_ids, 2)  # 随机抽取2个
```

### 4.2 医学场景:随机对照试验

```python
import random

def randomize_patients(patient_list, groups=2):
    """
    将患者随机分组(用于临床试验)

    参数:
        patient_list: 患者列表
        groups: 分组数(默认2组:对照组和治疗组)

    返回:
        字典,键为组名,值为患者列表
    """
    # 复制列表避免修改原列表
    patients = patient_list.copy()

    # 随机打乱
    random.shuffle(patients)

    # 分组
    group_size = len(patients) // groups
    result = {}

    for i in range(groups):
        start = i * group_size
        if i == groups - 1:  # 最后一组包含剩余所有患者
            end = len(patients)
        else:
            end = (i + 1) * group_size

        group_name = f"Group {i+1}"
        result[group_name] = patients[start:end]

    return result

# 使用
patients = [f"P{i:03d}" for i in range(1, 101)]  # 100个患者
groups = randomize_patients(patients, groups=2)

print(f"对照组({len(groups['Group 1'])}人): {groups['Group 1'][:5]}...")
print(f"治疗组({len(groups['Group 2'])}人): {groups['Group 2'][:5]}...")
```

## 5. pathlib - 现代路径操作(推荐)

### 5.1 基本用法

```python
from pathlib import Path

# 创建路径对象
path = Path("data/patients.csv")

# 路径拼接(使用/运算符)
data_dir = Path("data")
file_path = data_dir / "2025" / "01" / "patients.csv"
# 自动处理跨平台分隔符

# 检查路径
print(path.exists())  # 文件是否存在
print(path.is_file())  # 是否为文件
print(path.is_dir())  # 是否为目录

# 获取路径信息
print(path.name)  # patients.csv
print(path.stem)  # patients (不带扩展名)
print(path.suffix)  # .csv
print(path.parent)  # data

# 创建目录
Path("data/2025/01").mkdir(parents=True, exist_ok=True)

# 遍历目录
data_dir = Path("data")
for file in data_dir.glob("*.csv"):  # 所有CSV文件
    print(file)

for file in data_dir.rglob("*.csv"):  # 递归查找所有CSV
    print(file)

# 读写文件
path = Path("patient_record.txt")
path.write_text("患者姓名: 张三", encoding="utf-8")
content = path.read_text(encoding="utf-8")
```

### 5.2 医学场景示例

```python
from pathlib import Path
from datetime import datetime

def backup_patient_data(source_dir, backup_dir):
    """
    备份患者数据文件

    参数:
        source_dir: 源目录
        backup_dir: 备份目录
    """
    source = Path(source_dir)
    backup = Path(backup_dir)

    # 创建带时间戳的备份目录
    timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
    target_dir = backup / f"backup_{timestamp}"
    target_dir.mkdir(parents=True, exist_ok=True)

    # 复制所有CSV文件
    count = 0
    for csv_file in source.rglob("*.csv"):
        # 保持目录结构
        relative_path = csv_file.relative_to(source)
        target_file = target_dir / relative_path

        # 创建目标目录
        target_file.parent.mkdir(parents=True, exist_ok=True)

        # 复制文件
        target_file.write_bytes(csv_file.read_bytes())
        count += 1

    print(f"备份完成!共备份{count}个文件到 {target_dir}")

# 使用
backup_patient_data("patient_data", "backups")
```

## 6. collections - 高级数据结构

### 6.1 Counter - 计数器

```python
from collections import Counter

# 统计元素出现次数
diagnoses = ["高血压", "糖尿病", "高血压", "高血脂", "高血压", "糖尿病"]
counter = Counter(diagnoses)

print(counter)  # Counter({'高血压': 3, '糖尿病': 2, '高血脂': 1})
print(counter["高血压"])  # 3
print(counter.most_common(2))  # [('高血压', 3), ('糖尿病', 2)]

# 医学场景:统计诊断分布
from collections import Counter

patients = [
    {"name": "张三", "diagnosis": "高血压"},
    {"name": "李四", "diagnosis": "糖尿病"},
    {"name": "王五", "diagnosis": "高血压"},
    {"name": "赵六", "diagnosis": "高血脂"},
    {"name": "孙七", "diagnosis": "高血压"},
]

diagnoses = [p["diagnosis"] for p in patients]
diagnosis_count = Counter(diagnoses)

print("诊断统计:")
for diagnosis, count in diagnosis_count.most_common():
    percentage = count / len(patients) * 100
    print(f"{diagnosis}: {count}人 ({percentage:.1f}%)")
```

### 6.2 defaultdict - 带默认值的字典

```python
from collections import defaultdict

# 普通字典
patients = {}
patients["P001"] = "张三"
# patients["P002"]  # KeyError!

# defaultdict自动创建默认值
from collections import defaultdict

# 默认值为列表
patients_by_diagnosis = defaultdict(list)
patients_by_diagnosis["高血压"].append("张三")  # 自动创建列表
patients_by_diagnosis["高血压"].append("李四")
patients_by_diagnosis["糖尿病"].append("王五")

print(dict(patients_by_diagnosis))
# {'高血压': ['张三', '李四'], '糖尿病': ['王五']}

# 默认值为0
age_count = defaultdict(int)
ages = [45, 52, 45, 38, 45, 68]
for age in ages:
    age_count[age] += 1  # 自动从0开始

print(dict(age_count))  # {45: 3, 52: 1, 38: 1, 68: 1}
```

## 综合实战:患者数据分析工具

```python
import os
import json
from datetime import datetime, timedelta
from collections import Counter
from pathlib import Path

class PatientDataAnalyzer:
    """患者数据分析工具"""

    def __init__(self, data_file):
        self.data_file = Path(data_file)
        self.patients = self._load_data()

    def _load_data(self):
        """加载患者数据"""
        if not self.data_file.exists():
            return []

        with open(self.data_file, "r", encoding="utf-8") as f:
            return json.load(f)

    def add_patient(self, patient_info):
        """添加患者"""
        # 生成ID
        patient_info["id"] = f"P{len(self.patients)+1:04d}"
        patient_info["created_at"] = datetime.now().strftime("%Y-%m-%d %H:%M:%S")

        self.patients.append(patient_info)
        self._save_data()

    def _save_data(self):
        """保存数据"""
        self.data_file.parent.mkdir(parents=True, exist_ok=True)
        with open(self.data_file, "w", encoding="utf-8") as f:
            json.dump(self.patients, f, ensure_ascii=False, indent=2)

    def diagnosis_statistics(self):
        """诊断统计"""
        diagnoses = [p["diagnosis"] for p in self.patients]
        counter = Counter(diagnoses)

        print("\n诊断统计:")
        print("="*50)
        for diagnosis, count in counter.most_common():
            percentage = count / len(self.patients) * 100
            print(f"{diagnosis:<20} {count:>3}人 ({percentage:>5.1f}%)")
        print("="*50)

    def age_distribution(self):
        """年龄分布"""
        ages = [p["age"] for p in self.patients]

        print("\n年龄统计:")
        print("="*50)
        print(f"平均年龄: {sum(ages)/len(ages):.1f}岁")
        print(f"最小年龄: {min(ages)}岁")
        print(f"最大年龄: {max(ages)}岁")

        # 年龄段分布
        age_groups = {"<40": 0, "40-60": 0, ">60": 0}
        for age in ages:
            if age < 40:
                age_groups["<40"] += 1
            elif age <= 60:
                age_groups["40-60"] += 1
            else:
                age_groups[">60"] += 1

        for group, count in age_groups.items():
            percentage = count / len(ages) * 100
            print(f"{group}岁: {count}人 ({percentage:.1f}%)")
        print("="*50)

    def export_report(self, output_file):
        """导出分析报告"""
        report_lines = []
        report_lines.append("="*60)
        report_lines.append("患者数据分析报告")
        report_lines.append(f"生成时间: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}")
        report_lines.append("="*60)
        report_lines.append(f"\n总患者数: {len(self.patients)}人\n")

        # 诊断统计
        diagnoses = [p["diagnosis"] for p in self.patients]
        counter = Counter(diagnoses)
        report_lines.append("诊断分布:")
        for diagnosis, count in counter.most_common():
            percentage = count / len(self.patients) * 100
            report_lines.append(f"  {diagnosis}: {count}人 ({percentage:.1f}%)")

        # 保存报告
        output_path = Path(output_file)
        output_path.write_text("\n".join(report_lines), encoding="utf-8")
        print(f"\n报告已保存到: {output_file}")

# 使用示例
analyzer = PatientDataAnalyzer("data/patients.json")

# 添加患者
analyzer.add_patient({
    "name": "张三",
    "age": 45,
    "gender": "男",
    "diagnosis": "高血压"
})

# 统计分析
analyzer.diagnosis_statistics()
analyzer.age_distribution()

# 导出报告
analyzer.export_report("reports/patient_analysis.txt")
```

## 💡 关键要点

### 常用标准库总结

| 库 | 用途 | 核心功能 |
|---|------|---------|
| **os** | 文件系统操作 | 目录、文件操作 |
| **pathlib** | 现代路径操作 | 面向对象的路径 |
| **datetime** | 日期时间 | 计算、格式化 |
| **json** | JSON处理 | 数据序列化 |
| **random** | 随机数 | 随机化、抽样 |
| **collections** | 高级数据结构 | Counter, defaultdict |

### 何时使用标准库?

- 文件操作 → os/pathlib
- 日期计算 → datetime
- 配置文件 → json
- 统计计数 → collections.Counter
- 随机分组 → random

## 下一步

掌握了标准库后,下一节[实战:批量重命名DICOM文件](3.6-practice-rename.md),我们将完成第一个实用工具!

---

## 🔨 练习任务

```python
# 任务1: 文件整理工具
# 将桌面的文件按扩展名分类到不同文件夹

# 任务2: 随访提醒系统
# 读取患者数据,计算下次随访日期,生成提醒清单

# 任务3: 诊断统计报告
# 读取病历JSON文件,统计各种诊断的分布,生成报告
```
