# 2.7 实战练习:设计一个随访提醒逻辑

## 项目背景

你是一名慢病管理医生,负责管理50名糖尿病患者。每位患者需要定期随访:
- 血糖控制良好者:3个月随访一次
- 血糖控制欠佳者:1个月随访一次
- 新诊断患者:2周随访一次

**你的任务**:设计一个自动化随访提醒系统,每天检查哪些患者需要随访。

## 需求分析

### 功能需求

1. **存储患者信息**
   - 姓名、年龄、联系电话
   - 上次随访日期
   - 血糖控制状态(良好/欠佳/新诊断)

2. **计算下次随访日期**
   - 根据血糖控制状态确定间隔
   - 自动计算到期日期

3. **生成提醒清单**
   - 找出所有需要随访的患者
   - 按紧急程度排序
   - 输出格式化报告

### 涉及的编程概念

✅ **变量** - 存储患者信息
✅ **数据类型** - 字典、列表、日期
✅ **函数** - 封装计算逻辑
✅ **条件判断** - 根据状态做决策
✅ **循环** - 批量处理患者

## 步骤1:定义数据结构

### 思考:如何存储患者信息?

```python
# 单个患者数据
patient = {
    "name": "张三",
    "age": 55,
    "phone": "13800138000",
    "last_visit": "2025-01-01",  # 上次随访日期
    "glucose_control": "良好",    # 血糖控制状态
    "avg_glucose": 6.5            # 平均血糖(mmol/L)
}

# 多个患者 - 列表
patients = [
    {"name": "张三", "last_visit": "2025-01-01", "glucose_control": "良好"},
    {"name": "李四", "last_visit": "2024-12-15", "glucose_control": "欠佳"},
    # ...更多患者
]
```

## 步骤2:计算随访间隔

### 编写函数:根据状态确定间隔天数

```python
def get_followup_interval(glucose_control):
    """
    根据血糖控制状态获取随访间隔天数

    参数:
    glucose_control: 血糖控制状态("良好"/"欠佳"/"新诊断")

    返回:
    随访间隔天数(int)
    """
    if glucose_control == "良好":
        return 90  # 3个月
    elif glucose_control == "欠佳":
        return 30  # 1个月
    elif glucose_control == "新诊断":
        return 14  # 2周
    else:
        return 30  # 默认1个月

# 测试
print(get_followup_interval("良好"))   # 90
print(get_followup_interval("欠佳"))   # 30
print(get_followup_interval("新诊断")) # 14
```

## 步骤3:计算下次随访日期

### 使用datetime模块处理日期

```python
from datetime import datetime, timedelta

def calculate_next_visit(last_visit_date, glucose_control):
    """
    计算下次随访日期

    参数:
    last_visit_date: 上次随访日期(字符串格式"YYYY-MM-DD")
    glucose_control: 血糖控制状态

    返回:
    下次随访日期(datetime对象)
    """
    # 将字符串转为日期对象
    last_visit = datetime.strptime(last_visit_date, "%Y-%m-%d")

    # 获取间隔天数
    interval_days = get_followup_interval(glucose_control)

    # 计算下次随访日期
    next_visit = last_visit + timedelta(days=interval_days)

    return next_visit

# 测试
next_date = calculate_next_visit("2025-01-01", "良好")
print(f"下次随访日期: {next_date.strftime('%Y-%m-%d')}")
# 输出: 下次随访日期: 2025-04-01
```

## 步骤4:检查是否需要随访

### 编写判断函数

```python
from datetime import datetime

def needs_followup(last_visit_date, glucose_control, check_date=None):
    """
    判断患者是否需要随访

    参数:
    last_visit_date: 上次随访日期
    glucose_control: 血糖控制状态
    check_date: 检查日期(默认为今天)

    返回:
    (是否需要随访(bool), 距离到期天数(int))
    """
    # 默认检查日期为今天
    if check_date is None:
        check_date = datetime.now()
    elif isinstance(check_date, str):
        check_date = datetime.strptime(check_date, "%Y-%m-%d")

    # 计算下次随访日期
    next_visit = calculate_next_visit(last_visit_date, glucose_control)

    # 计算距离到期天数
    days_until = (next_visit - check_date).days

    # 如果已到期或即将到期(7天内)
    needs_visit = days_until <= 7

    return needs_visit, days_until

# 测试
should_visit, days = needs_followup("2025-01-01", "欠佳", "2025-02-05")
print(f"需要随访: {should_visit}, 距离到期: {days}天")
# 输出: 需要随访: True, 距离到期: -5天 (已逾期5天)
```

## 步骤5:批量处理患者列表

### 完整示例数据

```python
from datetime import datetime

# 患者列表
patients = [
    {
        "name": "张三",
        "age": 55,
        "phone": "13800138001",
        "last_visit": "2024-12-15",
        "glucose_control": "良好",
        "avg_glucose": 6.5
    },
    {
        "name": "李四",
        "age": 62,
        "phone": "13800138002",
        "last_visit": "2025-01-05",
        "glucose_control": "欠佳",
        "avg_glucose": 8.2
    },
    {
        "name": "王五",
        "age": 48,
        "phone": "13800138003",
        "last_visit": "2025-01-20",
        "glucose_control": "新诊断",
        "avg_glucose": 9.5
    },
    {
        "name": "赵六",
        "age": 68,
        "phone": "13800138004",
        "last_visit": "2024-11-10",
        "glucose_control": "良好",
        "avg_glucose": 6.8
    },
    {
        "name": "孙七",
        "age": 52,
        "phone": "13800138005",
        "last_visit": "2025-01-10",
        "glucose_control": "欠佳",
        "avg_glucose": 7.8
    }
]
```

### 生成随访提醒报告

```python
def generate_followup_report(patients, check_date=None):
    """
    生成随访提醒报告

    参数:
    patients: 患者列表
    check_date: 检查日期(默认今天)

    返回:
    需要随访的患者列表
    """
    if check_date is None:
        check_date = datetime.now()
    elif isinstance(check_date, str):
        check_date = datetime.strptime(check_date, "%Y-%m-%d")

    # 存储需要随访的患者
    followup_needed = []

    print("="*80)
    print(f"随访提醒报告 - {check_date.strftime('%Y年%m月%d日')}")
    print("="*80)

    # 遍历所有患者
    for patient in patients:
        needs_visit, days_until = needs_followup(
            patient["last_visit"],
            patient["glucose_control"],
            check_date
        )

        if needs_visit:
            # 添加到提醒列表
            patient_info = {
                "name": patient["name"],
                "phone": patient["phone"],
                "days_until": days_until,
                "glucose_control": patient["glucose_control"],
                "avg_glucose": patient["avg_glucose"]
            }
            followup_needed.append(patient_info)

    # 按紧急程度排序(逾期天数从多到少)
    followup_needed.sort(key=lambda p: p["days_until"])

    # 打印报告
    if len(followup_needed) == 0:
        print("\n✓ 今日无需随访患者")
    else:
        print(f"\n⚠️  需要随访患者: {len(followup_needed)}人\n")

        for i, patient in enumerate(followup_needed, 1):
            # 确定紧急程度
            if patient["days_until"] < 0:
                urgency = f"⭐ 已逾期{abs(patient['days_until'])}天"
            elif patient["days_until"] == 0:
                urgency = "🔴 今日到期"
            else:
                urgency = f"🟡 {patient['days_until']}天后到期"

            print(f"{i}. {patient['name']} - {patient['phone']}")
            print(f"   状态: {patient['glucose_control']} | 平均血糖: {patient['avg_glucose']} mmol/L")
            print(f"   紧急度: {urgency}")
            print()

    print("="*80)
    print(f"报告生成完毕 | 总患者数: {len(patients)}人 | 需随访: {len(followup_needed)}人")
    print("="*80)

    return followup_needed

# 使用示例(模拟2025年2月10日检查)
followup_list = generate_followup_report(patients, check_date="2025-02-10")
```

输出:
```
================================================================================
随访提醒报告 - 2025年02月10日
================================================================================

⚠️  需要随访患者: 4人

1. 赵六 - 13800138004
   状态: 良好 | 平均血糖: 6.8 mmol/L
   紧急度: ⭐ 已逾期8天

2. 李四 - 13800138002
   状态: 欠佳 | 平均血糖: 8.2 mmol/L
   紧急度: ⭐ 已逾期6天

3. 王五 - 13800138003
   状态: 新诊断 | 平均血糖: 9.5 mmol/L
   紧急度: 🟡 4天后到期

4. 孙七 - 13800138005
   状态: 欠佳 | 平均血糖: 7.8 mmol/L
   紧急度: 🟡 6天后到期

================================================================================
报告生成完毕 | 总患者数: 5人 | 需随访: 4人
================================================================================
```

## 步骤6:添加自动化通知功能

### 扩展:生成短信提醒内容

```python
def generate_sms_content(patient_info, days_until):
    """
    生成短信提醒内容

    参数:
    patient_info: 患者信息字典
    days_until: 距离到期天数

    返回:
    短信内容(str)
    """
    name = patient_info["name"]

    if days_until < 0:
        message = f"【慢病随访】{name}您好,您的随访已逾期{abs(days_until)}天,请尽快联系医生安排复诊。联系电话:xxx-xxxx"
    elif days_until == 0:
        message = f"【慢病随访】{name}您好,您今日需要随访,请联系医生安排时间。联系电话:xxx-xxxx"
    else:
        message = f"【慢病随访】{name}您好,您的下次随访将在{days_until}天后到期,请提前安排时间。联系电话:xxx-xxxx"

    return message

# 为需要随访的患者生成短信
print("\n短信提醒内容:")
print("="*80)
for patient in followup_list[:3]:  # 只显示前3个
    sms = generate_sms_content(patient, patient["days_until"])
    print(f"发送给 {patient['phone']}:")
    print(sms)
    print()
```

## 完整代码整合

### 将所有功能整合到一起

```python
from datetime import datetime, timedelta

class FollowUpManager:
    """随访管理系统"""

    def __init__(self, patients):
        """初始化,传入患者列表"""
        self.patients = patients

    @staticmethod
    def get_followup_interval(glucose_control):
        """获取随访间隔天数"""
        intervals = {
            "良好": 90,
            "欠佳": 30,
            "新诊断": 14
        }
        return intervals.get(glucose_control, 30)

    @staticmethod
    def calculate_next_visit(last_visit_date, glucose_control):
        """计算下次随访日期"""
        last_visit = datetime.strptime(last_visit_date, "%Y-%m-%d")
        interval = FollowUpManager.get_followup_interval(glucose_control)
        return last_visit + timedelta(days=interval)

    @staticmethod
    def needs_followup(last_visit_date, glucose_control, check_date, threshold_days=7):
        """判断是否需要随访"""
        next_visit = FollowUpManager.calculate_next_visit(last_visit_date, glucose_control)
        days_until = (next_visit - check_date).days
        return days_until <= threshold_days, days_until

    def generate_report(self, check_date=None):
        """生成随访报告"""
        if check_date is None:
            check_date = datetime.now()
        elif isinstance(check_date, str):
            check_date = datetime.strptime(check_date, "%Y-%m-%d")

        followup_needed = []

        for patient in self.patients:
            needs_visit, days_until = self.needs_followup(
                patient["last_visit"],
                patient["glucose_control"],
                check_date
            )

            if needs_visit:
                followup_needed.append({
                    **patient,  # 包含所有原始信息
                    "days_until": days_until
                })

        # 排序
        followup_needed.sort(key=lambda p: p["days_until"])

        # 打印报告
        self._print_report(followup_needed, check_date)

        return followup_needed

    def _print_report(self, followup_list, check_date):
        """打印格式化报告"""
        print("="*80)
        print(f"随访提醒报告 - {check_date.strftime('%Y年%m月%d日')}")
        print("="*80)

        if not followup_list:
            print("\n✓ 今日无需随访患者")
        else:
            print(f"\n⚠️  需要随访患者: {len(followup_list)}人\n")

            for i, patient in enumerate(followup_list, 1):
                if patient["days_until"] < 0:
                    urgency = f"⭐ 已逾期{abs(patient['days_until'])}天"
                elif patient["days_until"] == 0:
                    urgency = "🔴 今日到期"
                else:
                    urgency = f"🟡 {patient['days_until']}天后到期"

                print(f"{i}. {patient['name']} ({patient['age']}岁) - {patient['phone']}")
                print(f"   状态: {patient['glucose_control']} | 平均血糖: {patient['avg_glucose']} mmol/L")
                print(f"   上次随访: {patient['last_visit']} | {urgency}")
                print()

        print("="*80)
        print(f"总患者数: {len(self.patients)}人 | 需随访: {len(followup_list)}人")
        print("="*80)

# 使用面向对象的方式
manager = FollowUpManager(patients)
followup_list = manager.generate_report(check_date="2025-02-10")
```

## 💡 知识回顾

### 本项目用到的编程概念

| 概念 | 应用场景 | 代码示例 |
|------|---------|---------|
| **变量** | 存储患者信息 | `patient_name = "张三"` |
| **字典** | 结构化患者数据 | `{"name": "张三", "age": 55}` |
| **列表** | 管理多个患者 | `patients = [patient1, patient2]` |
| **函数** | 封装计算逻辑 | `def calculate_next_visit()` |
| **条件判断** | 根据状态决策 | `if glucose_control == "良好"` |
| **循环** | 批量处理患者 | `for patient in patients` |
| **日期处理** | 计算随访日期 | `timedelta(days=90)` |

### 编程思维流程

```
1. 分析需求
   └─ 需要什么功能?

2. 设计数据结构
   └─ 如何存储信息?

3. 拆分子问题
   ├─ 计算间隔
   ├─ 计算日期
   ├─ 判断是否到期
   └─ 生成报告

4. 逐个实现函数
   └─ 一个函数解决一个问题

5. 整合测试
   └─ 组合所有功能
```

## 扩展练习

### 练习1:添加提前提醒天数配置

```python
# 修改needs_followup函数,允许自定义提醒阈值
def needs_followup(last_visit, glucose_control, check_date, alert_days=7):
    # 你的代码
    pass
```

### 练习2:按科室分组

```python
# 为患者添加"科室"字段,生成分科室报告
def generate_report_by_department(patients):
    # 提示:使用字典存储不同科室的患者列表
    pass
```

### 练习3:导出为Excel

```python
# 使用pandas将随访清单导出为Excel
import pandas as pd

def export_to_excel(followup_list, filename="随访清单.xlsx"):
    # 你的代码
    pass
```

### 练习4:发送邮件提醒

```python
# 使用email库发送邮件提醒
def send_email_reminder(patient_email, patient_name, days_until):
    # 你的代码
    pass
```

## 下一步

恭喜!你已经完成了编程思维入门章节。通过这个随访提醒系统,你:

✅ 理解了变量、数据类型、函数、条件判断、循环等核心概念
✅ 学会了用编程思维分析和解决实际问题
✅ 掌握了将医学需求转化为代码的方法

**接下来**:在[第3章](../../part1/chapter3/3.1-why-python.md),我们将开始学习Python的具体语法,让你真正能够编写可运行的程序!

---

## 🎯 完整挑战任务

### 任务:实现一个完整的慢病管理系统

**要求**:
1. 支持添加、修改、删除患者
2. 自动计算下次随访日期
3. 生成每日提醒报告
4. 统计血糖控制达标率
5. 输出可视化图表(提示:用matplotlib)

**提示**:
- 从简单功能开始
- 逐步添加新功能
- 使用AI辅助调试

> 💡 不要害怕出错,编程就是不断试错的过程!在下一章我们会学习如何调试代码。

**记住**:编程不是背代码,而是学会分析问题和设计解决方案!
