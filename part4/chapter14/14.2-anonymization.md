# 14.2 数据脱敏技术

## 什么是数据脱敏?

**数据脱敏**(Data Anonymization/De-identification):
```
原始数据 → 脱敏处理 → 无法识别个人身份

目标: 保护隐私的同时保留数据的分析价值
```

## 脱敏技术分类

### 1. 删除(Deletion)

**直接删除标识符**:
```python
# 删除姓名、身份证号、电话等
df_anon = df.drop(['name', 'id_number', 'phone'], axis=1)
```

**适用**: 不需要这些字段时
**风险**: 低

### 2. 替换(Substitution)

**用假数据替换**:
```python
from faker import Faker

fake = Faker('zh_CN')

df['name'] = [fake.name() for _ in range(len(df))]
df['phone'] = [fake.phone_number() for _ in range(len(df))]
df['address'] = [fake.address() for _ in range(len(df))]
```

**适用**: 需要保留字段但不需要真实值
**风险**: 低

### 3. 泛化(Generalization)

**降低数据精度**:
```python
# 年龄分组
def generalize_age(age):
    if age < 18:
        return "0-17"
    elif age < 30:
        return "18-29"
    elif age < 40:
        return "30-39"
    elif age < 50:
        return "40-49"
    elif age < 60:
        return "50-59"
    else:
        return "60+"

df['age_group'] = df['age'].apply(generalize_age)
df = df.drop('age', axis=1)

# 地址泛化(只保留省份)
df['province'] = df['address'].str[:2]
df = df.drop('address', axis=1)

# 日期泛化(只保留年月)
df['visit_month'] = pd.to_datetime(df['visit_date']).dt.to_period('M')
df = df.drop('visit_date', axis=1)
```

**适用**: 需要统计分析但不需要精确值
**风险**: 中

### 4. 扰动(Perturbation)

**添加随机噪声**:
```python
import numpy as np

# 给数值数据添加噪声
noise = np.random.normal(0, 1, len(df))
df['weight_anonymized'] = df['weight'] + noise

# 确保合理范围
df['weight_anonymized'] = df['weight_anonymized'].clip(30, 200)
```

**适用**: 需要保持数据分布但不需要精确值
**风险**: 中

### 5. 哈希(Hashing)

**单向加密**:
```python
import hashlib

def hash_value(value, salt='random_salt_123'):
    """单向哈希"""
    return hashlib.sha256(f"{value}{salt}".encode()).hexdigest()[:16]

df['patient_id_hash'] = df['patient_id'].apply(hash_value)
df = df.drop('patient_id', axis=1)
```

**适用**: 需要唯一标识但不需要知道真实ID
**风险**: 低(如果salt保密)

### 6. 加密(Encryption)

**可逆加密**:
```python
from cryptography.fernet import Fernet

# 生成密钥(保存好!)
key = Fernet.generate_key()
cipher = Fernet(key)

# 加密
df['name_encrypted'] = df['name'].apply(
    lambda x: cipher.encrypt(x.encode()).decode()
)

# 解密(需要密钥)
df['name_decrypted'] = df['name_encrypted'].apply(
    lambda x: cipher.decrypt(x.encode()).decode()
)
```

**适用**: 需要可逆恢复时
**风险**: 中(取决于密钥管理)

## 完整脱敏工具类

```python
"""
医疗数据脱敏工具
"""

import pandas as pd
import numpy as np
import hashlib
from faker import Faker
from cryptography.fernet import Fernet

class MedicalDataAnonymizer:
    """医疗数据脱敏器"""

    def __init__(self, salt='your_random_salt'):
        self.salt = salt
        self.fake = Faker('zh_CN')
        self.key = Fernet.generate_key()
        self.cipher = Fernet(self.key)

    def anonymize_dataframe(self, df, config):
        """
        根据配置脱敏DataFrame

        Args:
            df: 原始DataFrame
            config: 脱敏配置字典
                {
                    'name': 'replace',
                    'id_number': 'delete',
                    'age': 'generalize',
                    'weight': 'perturb',
                    'patient_id': 'hash'
                }

        Returns:
            脱敏后的DataFrame
        """
        df_anon = df.copy()

        for column, method in config.items():
            if column not in df_anon.columns:
                continue

            if method == 'delete':
                df_anon = df_anon.drop(column, axis=1)

            elif method == 'replace':
                if column == 'name':
                    df_anon[column] = [self.fake.name() for _ in range(len(df_anon))]
                elif column == 'phone':
                    df_anon[column] = [self.fake.phone_number() for _ in range(len(df_anon))]
                elif column == 'address':
                    df_anon[column] = [self.fake.address() for _ in range(len(df_anon))]

            elif method == 'generalize':
                if column == 'age':
                    df_anon[f'{column}_group'] = df_anon[column].apply(self._generalize_age)
                    df_anon = df_anon.drop(column, axis=1)
                elif 'date' in column.lower():
                    df_anon[f'{column}_month'] = pd.to_datetime(df_anon[column]).dt.to_period('M')
                    df_anon = df_anon.drop(column, axis=1)

            elif method == 'perturb':
                noise = np.random.normal(0, df_anon[column].std() * 0.05, len(df_anon))
                df_anon[column] = df_anon[column] + noise

            elif method == 'hash':
                df_anon[f'{column}_hash'] = df_anon[column].apply(self._hash_value)
                df_anon = df_anon.drop(column, axis=1)

            elif method == 'mask':
                df_anon[column] = df_anon[column].apply(self._mask_string)

        return df_anon

    def _hash_value(self, value):
        """哈希值"""
        return hashlib.sha256(f"{value}{self.salt}".encode()).hexdigest()[:16]

    def _generalize_age(self, age):
        """年龄泛化"""
        if pd.isna(age):
            return None
        if age < 18:
            return "0-17"
        elif age < 30:
            return "18-29"
        elif age < 40:
            return "30-39"
        elif age < 50:
            return "40-49"
        elif age < 60:
            return "50-59"
        else:
            return "60+"

    def _mask_string(self, value):
        """字符串掩码"""
        if pd.isna(value) or len(str(value)) == 0:
            return value

        value_str = str(value)
        if len(value_str) <= 2:
            return value_str[0] + '*'
        else:
            return value_str[0] + '*' * (len(value_str) - 2) + value_str[-1]

    def save_key(self, key_file='encryption_key.key'):
        """保存加密密钥"""
        with open(key_file, 'wb') as f:
            f.write(self.key)

    def load_key(self, key_file='encryption_key.key'):
        """加载加密密钥"""
        with open(key_file, 'rb') as f:
            self.key = f.read()
            self.cipher = Fernet(self.key)

# 使用示例
if __name__ == "__main__":
    # 创建测试数据
    df = pd.DataFrame({
        'patient_id': ['P001', 'P002', 'P003'],
        'name': ['张三', '李四', '王五'],
        'id_number': ['110101199001011234', '110101199102021234', '110101199203031234'],
        'age': [35, 42, 28],
        'gender': ['男', '女', '男'],
        'phone': ['13800138000', '13900139000', '13700137000'],
        'address': ['北京市朝阳区xx街道', '上海市浦东新区yy路', '广州市天河区zz大道'],
        'weight': [70.5, 62.3, 75.8],
        'diagnosis': ['高血压', '糖尿病', '冠心病']
    })

    print("原始数据:")
    print(df)
    print("\n" + "=" * 80 + "\n")

    # 脱敏配置
    config = {
        'patient_id': 'hash',
        'name': 'replace',
        'id_number': 'delete',
        'age': 'generalize',
        'phone': 'mask',
        'address': 'replace',
        'weight': 'perturb'
    }

    # 执行脱敏
    anonymizer = MedicalDataAnonymizer()
    df_anonymized = anonymizer.anonymize_dataframe(df, config)

    print("脱敏后数据:")
    print(df_anonymized)

    # 保存
    df_anonymized.to_excel('patient_data_anonymized.xlsx', index=False)
    print("\n✓ 脱敏数据已保存")
```

### 输出示例

```
原始数据:
  patient_id name          id_number  age gender        phone  ...
0       P001   张三  110101199001011234   35     男  13800138000  ...
1       P002   李四  110101199102021234   42     女  13900139000  ...
2       P003   王五  110101199203031234   28     男  13700137000  ...

================================================================================

脱敏后数据:
  patient_id_hash    name age_group gender       phone  ...
0    a7b3c1d2e5f6  陈娜娜     30-39     男  1**********  ...
1    b8c4d3e6f7g8  刘强强     40-49     女  1**********  ...
2    c9d5e7f8g9h0  赵明明     18-29     男  1**********  ...

✓ 脱敏数据已保存
```

## K-匿名性检查

**K-匿名性**: 数据集中每条记录至少有k-1条其他记录在准标识符上相同

```python
def check_k_anonymity(df, quasi_identifiers, k=5):
    """
    检查K-匿名性

    Args:
        df: DataFrame
        quasi_identifiers: 准标识符列表(如['age_group', 'gender', 'city'])
        k: K值

    Returns:
        是否满足K-匿名性
    """
    # 按准标识符分组计数
    group_sizes = df.groupby(quasi_identifiers).size()

    # 检查是否所有组都>=k
    min_group_size = group_sizes.min()

    print(f"最小组大小: {min_group_size}")
    print(f"K-匿名性(k={k}): {'✓ 满足' if min_group_size >= k else '✗ 不满足'}")

    # 显示小于k的组
    small_groups = group_sizes[group_sizes < k]
    if len(small_groups) > 0:
        print(f"\n有{len(small_groups)}个组小于k={k}:")
        print(small_groups.head())

    return min_group_size >= k

# 使用示例
quasi_identifiers = ['age_group', 'gender', 'diagnosis']
check_k_anonymity(df_anonymized, quasi_identifiers, k=2)
```

## 脱敏风险评估

```python
class AnonymizationRiskAssessor:
    """脱敏风险评估"""

    @staticmethod
    def assess_risk(df_original, df_anonymized):
        """评估脱敏风险"""

        print("脱敏风险评估报告")
        print("=" * 60)

        # 1. 直接标识符检查
        direct_identifiers = ['name', 'id_number', 'phone', 'email']
        remaining = [col for col in direct_identifiers if col in df_anonymized.columns]

        if remaining:
            print("⚠️  警告: 仍包含直接标识符:", remaining)
        else:
            print("✓ 直接标识符已全部删除")

        # 2. 数据保真度
        common_columns = set(df_original.columns) & set(df_anonymized.columns)
        if common_columns:
            print(f"\n保留字段: {len(common_columns)}个")

        # 3. 唯一性检查
        for col in df_anonymized.columns:
            unique_ratio = df_anonymized[col].nunique() / len(df_anonymized)
            if unique_ratio > 0.9:
                print(f"⚠️  {col} 唯一性过高 ({unique_ratio:.1%}), 可能存在重识别风险")

        print("\n" + "=" * 60)
```

## 最佳实践

### 1. 分层脱敏

```python
# 不同用途使用不同脱敏程度
def anonymize_for_purpose(df, purpose):
    """根据用途脱敏"""

    if purpose == 'internal_analysis':
        # 内部分析: 轻度脱敏
        config = {
            'name': 'mask',
            'id_number': 'hash',
            'phone': 'mask'
        }
    elif purpose == 'external_sharing':
        # 外部分享: 重度脱敏
        config = {
            'name': 'delete',
            'id_number': 'delete',
            'phone': 'delete',
            'age': 'generalize',
            'address': 'delete',
            'weight': 'perturb'
        }
    elif purpose == 'publication':
        # 发表: 最高级别脱敏
        config = {
            'name': 'delete',
            'id_number': 'delete',
            'phone': 'delete',
            'age': 'generalize',
            'address': 'delete',
            'weight': 'generalize',
            'patient_id': 'delete'
        }

    anonymizer = MedicalDataAnonymizer()
    return anonymizer.anonymize_dataframe(df, config)
```

### 2. 审计日志

```python
import logging
from datetime import datetime

def log_anonymization(df_original, df_anonymized, config):
    """记录脱敏操作"""

    logging.basicConfig(
        filename=f'anonymization_{datetime.now().strftime("%Y%m%d_%H%M%S")}.log',
        level=logging.INFO
    )

    logging.info(f"脱敏时间: {datetime.now()}")
    logging.info(f"原始记录数: {len(df_original)}")
    logging.info(f"脱敏后记录数: {len(df_anonymized)}")
    logging.info(f"脱敏配置: {config}")
    logging.info(f"删除的列: {set(df_original.columns) - set(df_anonymized.columns)}")
```

## 检查清单

- [ ] 删除所有直接标识符
- [ ] 泛化准标识符
- [ ] 满足K-匿名性(k≥5)
- [ ] 通过风险评估
- [ ] 保留数据分析价值
- [ ] 记录脱敏日志
- [ ] 测试无法重识别

## 下一步

[14.3 AI工具使用的隐私风险](14.3-ai-privacy-risks.md) - 使用ChatGPT等工具的注意事项
